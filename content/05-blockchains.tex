
\chapter{Blockchain Technology}
\label{ch:blockchain}

\section{Introduction to Blockchains and the Problems they can solve}
\label{ch:blockchain:intro}

Blockchains are fundamentally an immutable ledger: they allow data to be recorded in an append-only manner and such that the order and content of the ledger cannot be disputed in the future. Combined with a common, shared set of rules ---known as \emph{consensus}--- for how to add data to the chain and validate those data, a blockchain allows for mutually untrusting parties to agree on the content of a shared immutable ledger.

This forms the basis of cryptocurrencies where the transactions in the currency are entries into this ledger. The transactions themselves use other cryptographic functions to ensure their own rules ---which all parties can agree on--- and the chain is what allows a public system where no node is required to trust any other node, yet all nodes can agree on the content of the ledger.

I believe it was this lack of trust requirements that really allowed the blockchain technology to become popular. The first well known use of a blockchain was in the cryptocurrency Bitcoin (\url{https://bitcoin.org}) which has gone from interesting experiment to a global buzzword. One of the key factors in its success was the lack of central authority. There was no way to regulate trade in the coins and no restrictions on who could send or receive them. This would not have been possible without the trust-less distributed immutable ledger provided by the blockchain backbone of Bitcoin.

Blockchains can also be used without the public consensus rules in what is know as a Permissioned Blockchain. In this case the data are public but only authorized entities may write to it. The key feature here is that the public data are tamper-evident. Such systems can be used as public audit logs with a high trust from the public as entries cannot be retroactively altered.

Whilst cryptocurrencies were the first major application of blockchain technology there are other problems that can benefit from the decentralized nature and immutability. The two properties together imply a form of censorship resistance that centralized systems can never have --- that is, there is no authority that can intercede to perform the censorship, every node in the network has equal rites. Two examples where this is a desirable property are  the attempts to create decentralized alternatives to the most common \gls{dns} used on the Internet \needcite{unstoppable, namecoin, ethereum names} and the central \gls{pki} root(s) of trust used in many Operating Systems for certificate validation in \gls{tls}.

Blockchains have a major disadvantage to centralized ledgers in that the speed of transactions is often prohibitively slow for many applications. Using the Ethereum (\url{https://ethereum.org}) blockchain network as an example, at the time of writing the largest transaction volume in a single day was 1,406,016 on Thursday, September 17 2020 \needcite{etherscan.io} which equates to ~16.2 transactions per second compared to the Visa payment network which claims greater than 56,000 messages per second \needcite{visanet.co.uk}.


\section{Structure of a Blockchain}
\label{ch:blockchain:structure}

\begin{figure}[h]
    \centering
    \includesvg[width=\columnwidth]{figures/blockchain-chaining}
    \caption{Basic Blockchain Structure}
    \label{fig:basic-blockchain}
\end{figure}

Blockchains are at their core built from two simple principles. These two principles provide a foundation of the technology and number of useful properties. They are:

\begin{enumerate}
    \item Every block is linked to the previous block in a deterministic manner.
    \item Creating a block requires cost.
\end{enumerate}

Let us look at the first principle. The important word is \emph{deterministic}. Consider \autoref{fig:basic-blockchain}; each block has its identifier as the output of a cryptographic hash function over data from the payload of the block as well as the hash of the previous block. This way we cannot retrospectively change the contents of a block, as its hash would no longer validate, nor would the hash of any subsequent blocks. To rewrite a block in the chain, we would need to rewrite the entire thing from that block onwards, so that all the new hashes would be correct.

This would not be difficult to do if it weren't for the second principle which says that in order to create a block (referred to as \emph{mining} a block in this context), it will cost us something. In order to rewrite a block, you would need to pay that cost again for that block and for all subsequent blocks. As no-one has an unlimited budget, no-one is able to pay the cost to re-write the chain in a manner that would satisfy all other users of the blockchain and as such once the data is sufficiently deep into the chain it can be considered immutable. The way this cost is calculated is known as a consensus algorithm and ensures that all nodes can agree on the data in the chain as we will see later.

\subsection{Blocks and Hashes}
\label{ch:blockchain:structure:basics}

The figure Blockchains use cryptographic hash functions for a number of their properties. Here is a quick overview of the desirable security properties of a cryptographic hash function $H$:

\todo{better definitions, take from the book from intro to crypto? particularly for PRNG}

\begin{enumerate}
    \item \textbf{Preimage Resistance} Given a hash output $h$, it should be hard to find a message $m$ such that $H(m) = h$.
    \item \textbf{Second Preimage Resistance} Given a message $m_1$ and the output $H(m_1) = h$ it should be hard to find a message $m_2$ such that $H(m_2) = H(m_1) \equiv h$.
    \item \textbf{Collision Resistance} It should be hard to find two messages $m_1$ and $m_2$ such that $H(m_1) = H(m_2)$.
    \item \textbf{Psuedo-Randomness} The output from the function should be hard to distinguish from a random oracle. That is, there should be no discernable relation between the input and output and similar inputs should not produce similar outputs.
\end{enumerate}

Note that second preimage resistance is implied by collision resistance, however it is subtly different as we are not attempting to find \emph{any} collision, but a specific collision for a known message. The recent SHAttered \cite{katz_first_2017} attack on the SHA1 hash function was used to break collision resistance, not second preimage resistance. Blockchains use cryptographic hashes to link blocks together precisely because of second preimage resistance, which implies that we cannot feasibly forge a block while keeping the hash identical --- which would be the only way to insert a block without having to rewrite the entire following chain.

We see in \autoref{fig:basic-blockchain} the data we want to ensure are immutable --- the block payload, the previous block's hash and metadata --- are included in the block's own hash.  We can validate the block has not been tampered with by recomputing the hash and checking it matches the hash we expect. This also means we cannot change any of the block data without also changing the hash and if we change the hash then the next block will have the incorrect previous hash and the chain is broken.

\todo{ can I put some more in this section? feels short}

\subsection{Consensus}
\label{ch:blockchain:structure:consensus}

Consensus in a distributed system is the property that the honest nodes in the system will agree about the data in that system, even in the presence of adversarial nodes. This is the reason for the second principle mentioned in \autoref{ch:blockchain:intro}.

A blockchain peer-to-peer network consists of a group of nodes in a gossip network. Each node searches for other nodes and then \emph{gossips} with them. They swap knowledge of other nodes in the network to expand the number of peers they can attempt to connect to. They also swap knowledge of their view of the blockchain. If one node claims to know a longer chain it will tell its peers, and send the blocks to them. The receiving node must then validate that the block are valid. The node will use the consensus algorithm to check this. If the blocks are invalid, then the node will block the sender as a dishonest node, ensuring that eventually dishonest nodes are ejected from the network. If the blocks are valid, then the node can be sure that the creator of the block has indeed put in the cost to create it.

As more than one new block could be sent to a node at the same time, we need a second part to the consensus algorithm to ensure that the chain doesn't split into many chains. This is actually very simple and all blockchains I could fine use the "longest valid chain wins" heuristic. If a peer node can produce a longer valid chain, then the network will start to treat that as the true chain.

\todo{
    consensus has an endgame, in bitcoin miners are rewarded in the cryptocurrency for mining a block, and so they compete to do so. In a blockchain without a cryptocurrency, there is no reward, so why would anyone mine a block. \\
    the only reason to mine a block in our voting system is to ensure your vote is recorded. if votes are bundled then we have no incentive to mine as it costs, and "someone else will do it." \\
    if votes are one-per-block then each user must mine a block and it will cost them, which is something I am very much against and why I didn't want to use a cryptocurrency based chain. \\
    however there is no good proof of stake algorithm either, as there is "nothing at stake". \\
    basically the reason to use PoW is to prevent re-writing the chain. However for an election the transaction rate is low and there may be long periods when no votes are made, during this time blocks could be rebuilt - so we will need no-ops, and they should probably have higher difficulty than the vote blocks to keep votes quick.
}

The consensus method most often used in blockchains is known as a \gls{pow} and involves performing a computational task that takes a non-trivial amount of processing power to perform but a trivial amount to check it was performed correctly. The value invested is the computation work performed.

An early example of a \gls{pow} system is HashCash \cite{back_hashcash_2002} initially devised as a spam prevention mechanism. By adding a \gls{pow} requirement to email it would no longer be cheaper for spammers to send mail at volume. The main principle behind HashCash is to give a proof that some work has been done, specifically for a given commitment. The commitment is some data we wish to show we knew before we did the work. The \emph{work} involved is the computation time required to perform the hash function. A single hash requires a very small amount of work, so we want the prover to perform a very large number of hashes, however the verifier should not have to do much work at all. This may seem impossible as the pseudo-randomness property means that to be sure the prover has performed the hashes, the verifier would have to perform the same number of hashes.

The solution to this is to lower our requirement of proof from complete certainty to \emph{within a given probability}. Now we can take advantage of the psuedo-randomness of the hash function. As every input produces a random hash, each bit of the hash will be $0$ or $1$ with probability $1/2$. So producing a hash with the first bit $0$ has probability $1/2$. A hash with the first 2 bits $0$ has probability $1/2^2$. For a hash with the first $n$ bits $0$ the probability is $1/2^n$ and will on average take $2^n$ attempts to find. Now we can create our commitment $c$ with a shared method and append some randomness $r$ and calculate the hash $H(c || r) = h$. If the first $n$ bits of the hash are 0, we consider the work done, if not we create a new random value $r$ and try again. This will take on average $2^n$ attempts, but the verifier given $r$ can create the commitment $c$ and confirm that $H(c || r)$ starts with $n$ 0-bits with a single hash. Psuedo-code for this algorithm is shown in \autoref{fig:hashcash}.

\begin{figure}[h]
    \centering
    \begin{lstlisting}
        # right-shift by this amount will leave only the bits
        # we want to check are 0
        let shift = numberOfBitsInHashOutput - nBitsShouldBeZero

        function hashcash_prove (commitment) {
            do {
                # pick a random value for r
                let r = random()
                # until it verifies
            } while (!hashcash_verify(commitment, r))

            return r
        }

        function hashcash_verify (commitment, r) {
            # concatenate and apply hash function
            let h = hash(commitment || r)
            # after shift the result should be zero
            return (h >> shift == 0)
        }

        \end{lstlisting}
    \caption{Psuedo-code for the HashCash algorithm}
    \label{fig:hashcash}
\end{figure}

For a blockchain we can use a similar function using all the data that makes the block identifier hash as the commitment and trying values for the proof until a satisfactory value is found. What makes the value satisfactory will vary, and is determined by the shared rules of the system. In many implementations the \emph{difficulty} is variable to allow the chain to react to keep the rate of addition of blocks roughly constant.

As the blockchain needs new blocks added, performing the work required for \gls{pow} usually results in a reward for the miner, incentivizing miners to continue to add blocks. This rewards good behaviour in the system, but bad actors are not punished.

The second method of consensus is known as \gls{pos}. \todo{and is more difficult to explain}

\section{Transactions, Smart Contracts and other chains}
\label{ch:blockchain:types}

\todo{
    Public chains like cryptocurrencies, private chains like internal audit logs. Hybrid distributed ledgers for open viewing, but private updates. \\
    - Bitcoin: wallets and transactions: unspent tx buffer \\
    - Ethereum and smart contracts: Users vs Contracts, Solidity, the EVM, gas and eth. \\
}


\section{Trust in Blockchains}
\label{ch:blockchain:trust}

Trust is important in decentralized systems. With no authority to control access to the system, it is important to understand that nodes \emph{must not} trust each other. All nodes in the system are considered untrusted, but the consensus algorithm will ensure that the rules are followed. This does mean that all honest nodes need to be adhering to the same rules, but the dishonest parties cannot break them or the honest nodes will notice and ignore them.


That is of course a simplification, we have made the assumption that the consensus algorithm is secure against the adversarial nodes. There have been a number of proposed attacks against both \gls{pow} and \gls{pos} consensus algorithms \needcite{attacks on powpos}.