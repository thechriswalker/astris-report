
\chapter{Proposal for an Improved Protocol: Astris}
\label{ch:astris}

This chapter looks at a proposal for new e-voting protocol. The focus of the new protocol will be minimizing the trust requirements of the user. It will achieve this by distributing single points of trust as far as practical and ensuring real-time universal verifiability.

\begin{quote}
    ``There are only two hard things in Computer Science: cache invalidation and naming things.''

    \rightline{--- Phil Karlton\footnote{This quote was attributed to Phil Karlton by Tim Bray, first appearing on the Internet in 2005 \url(http://www.tbray.org/ongoing/When/200x/2005/12/23/UPI).}}
\end{quote}

Fortunately our protocol description does not touch on cache invalidation. However, the protocol bears a distinct resemblance to the Helios v4 protocol. This is due to the fact that many constructs within Helios are perfectly suited to application in this protocol. There are also significant differences in both the way elections are set up, voters registered and how the public bulletin board is constructed. Therefore, \emph{Astris} --- one of the daughters of Helios in Greek mythology --- seemed a fitting name.

\section{Objectives and Non-Objectives}
\label{ch:astris:aims}

Astris aims to lower the trust requirements in comparison to other voting systems while maintaining the key security properties. This is achieved through a combination of processes working together.

Firstly, the system is designed for all working to be done in the open or to be provably correct via public data. This is the primary function of using \gls{dlt} in the system --- to provide a platform that is publicly verifiable and immutable. After data is on the chain, it cannot be rewritten without nodes on the network noticing.

Secondly, the system is designed to reduce the possible single points of trust to distributed ones. No single entity will be able to decrypt the data on the chain. The registrar has a large amount of power over the system, being the one making the decisions about who is eligible or not. This is an unavoidable focus of power, but we mitigate it by ensuring that the registrar may only wield this power during the voter registration phase and not during the voting phase.

The ability to decrypt the final tally is gifted to the trustees, and only when working in concert through threshold cryptography. This means we have a bound on the number of trustees that must collude before any data is revealed. There is a trade-off here between robustness and security in the choice of our threshold. If we require that all trustees be honest, and we require them all to decrypt the final tally, this will be most secure and only one need be honest to prevent any secret data being decrypted. However, it now only takes a single dishonest party to break the system completely making the final result unknowable, as the withholding of a single decryption will reveal no information about the result. Same outcome would happen if any trustee lost their secret key before the vote decryption phase. On the other hand, if we lower the threshold too much, then fewer trustees need to be dishonest and collude before all the private votes can be decrypted.

There is no correct answer to this trade-off except to consider the circumstances of the election and the required security vs robustness. For example a national level election requires high security, but also must be robust. The electorate will not be happy if the election system fails at the end and has to be restarted, yet neither will they be happy if their votes are revealed. The way to increase both security and robustness is to increase the number of trustees, selecting them carefully to maximize the likelihood that they will not collude --- that is, where there is incentive for them to act correctly, and no shared motivation to collude with other parties. Once the number of trustees is high enough, we can choose a threshold where the probability of lost keys causing failure and the probability of the required amount of trustees colluding are both acceptably low.

Finally, it is worth reiterating that an e-voting system can never attain coercion-resistance (see \autoref{ch:ev:specific}), so we will not aim to cover that property.

We must make some assumptions about the environment in which this protocol will operate:

\begin{itemize}
    \item We are not ``programming Satan's computer'' \cite{andersonProgrammingSatanComputer1995}. That is we must assume that each entity can trust the use of their own computer system and the integrity of the software running on it.
    \item We assume the existence of a private communication channel that can be established as needed between any to entities in the system.
\end{itemize}

With this in mind, the aims of the Astris protocol are defined in \autoref{table:astris:aims}

\begin{table}[h]
    \centering
    \begin{tabular}{|Sr S{p{0.9\textwidth}}|}
        \hline
        \textbf{\#} & \textbf{Objective}                                                                                                                                                    \\
        \hline\hline
        \textbf{1}  & Create a voting protocol that is correct, secret, fair, robust, receipt-free, individually and universally verifiable, universally auditable and honours eligibility. \\
        \hline
        \textbf{2}  & Create a voting protocol with no single points of trust, minimizing trust requirements.                                                                               \\
        \hline
        \textbf{3}  & Create a voting protocol which maximizes auditability and transparency.                                                                                               \\
        \hline
    \end{tabular}
    \caption{Table of Objectives for the Astris Protocol}
    \label{table:astris:aims}
\end{table}


The non-goals of the protocol are:

\begin{itemize}
    \item To define the exact authentication protocol to prove eligibility.
    \item To define the \emph{correct} balance between security and robustness.
    \item To provide defence against a post-quantum adversary.
\end{itemize}

This last non-goal is an interesting one, that later work may wish to revisit. In order to create the protocol in the manner proposed, we will require a public key encryption system with the following properties:

\begin{itemize}
    \item There must be a distributed threshold key generation protocol without any party gaining knowledge of the secret key at any point during the protocol. This is important to ensure that there is no possibility to decrypt the data without a threshold of keyholders working together.
    \item It must be a probabilistic encryption. That is the same plaintext must not always encrypt to the same ciphertext. This is important as votes are going to have little variation in plaintext (i.e. they will be 1 or 0).
    \item It must support homomorphic addition. This is so we can add up the votes without decrypting them. There is an alternative to homomorphism in voting systems using mix-nets, but our protocol will homomorphism, and so requires an additive homomorphism.
    \item It must have a signature scheme, which can sign arbitrary messages.
    \item It must support verifiable encryption. We must be able to proof that our vote plaintext has a certain format, and the combined votes have a certain format. That is, we need to be able to prove that we voted for at most 1 candidate --- the vote for each candidate is either a 0 or a 1, and the sum over the votes for all candidates the sum of votes is also 0 or 1.
    \item It must support verifiable decryption. A trustee must be able to prove that their decryption of the tally is correct.
\end{itemize}

There are a number of quantum-resistant algorithms \needcite{LWE, Ring-LWE, NTRU, mulitvariate, supersingular ECC,... } that fit some or all of these properties. ElGamal, while relying on the \gls{dlp} which has shown to be insecure under Shor's alorigthm \cite{shorAlgorithmsQuantumComputation1994}, has all the required properties. Provided all else is equal, using a post-quantum algorithm would indeed lower trust requirements as it would be more likely that the publicly available audit data for the election could \emph{never} be decrypted by an adversary, whereas under ElGamal a post-quantum attack could reveal data. Therefore, should we be able to replace our quantum-vulnerable algorithm with a quantum-resistant one, we would further reduce trust requirements in our system, but this reduction would be orthogonal to any other aspect. It would merely be replacing one black box with another.

Given this and that the post-quantum algorithms are significantly more complex to implement in software, I leave that as future work and accept that the solution will not be optimally minimized without post-quantum algorithms but that the core of this protocol would be unchanged by switching to one. Due to this, \autoref{ch:astris:overview} will not mention any specific cryptography and the exact nature of the implementation will be detailed only in \autoref{ch:astris:detail}.

\section{Protocol Overview}
\label{ch:astris:overview}

The Astris protocol is split into distinct stages. There is a setup stage where the election parameters are chosen, the trustees named and the distributed secret key created. This stage also names the Registrar and enumerates all the eligible voters. Once this initial setup stage is complete, the data is put into a genesis block for the public audit chain for this election and the hash of the block becomes the election identifier used throughout the rest of the protocol. All further data are added to this chain, and any party wishing to verify the election as it happens can join the network and see all the blocks.

One section of the election parameters governs the timing of the phases, which will be used throughout the rest of the protocol.

The second stage is the parameter confirmation stage which is a timed stage. During this all the external parties --- the registrar and each of the trustees --- sign an acknowledgement that they agree with the data in the genesis block. Any further stages of the distributed key setup will happen here, so this may be a multi-step phase. Each signed payload is added to the chain. All confirmations must be added within the time bounds or the protocol is deemed failed and must be restarted. We note that at this stage we require \emph{all} parties to confirm, and the protocol can collapse due to a single failure. However, we have not involved the public yet, except early auditors, and so there is little problem in restarting the process, generating a new election ID.

After the parameter confirmation, we have the voter registration phase which is also a timed phase. During this phase, the voters must authenticate with the registrar and have the registrar sign their public key and voter id. The voter may then add this block to the chain, to show that their vote may be allowed and that it will be signed with their secret key. If eligible voters do not register to vote during this period, they may not cast a vote in the later vote casting stage.

The next stage is the vote casting stage, also timed. Once voting opens, a voter may cast a vote by encrypting a series of 0's or 1's in the order of the listed candidates. Alongside the encrypted votes the voter will create a series of \glsplural{zkp} showing that each ciphertext encrypts either a 0 or a 1. The voter will also create a proof that the overall sum of votes is less than or equal to the configured election parameter minimum. Finally, the voter creates a signature over the ballot data and voter id with their private key. This signature can then be verified using the previously published public key.

The last stage is the tally decryption stage, also timed. This poses the most threat to the integrity of the election as unless a threshold of trustees submits partial decryption results to the chain within the time bound, then the election will be void. It seems a legal incentive here would be necessary to ensure co-operation. Note that any entity may perform the homomorphic summation to get to the final encrypted tally, and once the threshold of partial decryption results have been published any entity may calculate the final result.

This process is visualized in \autoref{fig:astris-sequence}.

\begin{figure}[H]
    \centering
    \includesvg[width=\columnwidth]{figures/astris-protocol}
    \caption{Astris Protocol Sequence}
    \label{fig:astris-sequence}
\end{figure}

\section{Protocol Detail - V1.0}
\label{ch:astris:detail}

This section aims to describe the functioning of the Astris protocol version \texttt{1.0} unambiguously, such that there is enough information to build a functioning client, able to interoperate with the reference implementation.

All the data types mentioned are fully described in \autoref{appendix:datatypes} as they are quite verbose. When a data type is referenced it will be with a monospaced font such as \nameref{dt:elgamal:ct}.

\subsection{Peer-to-Peer Communication}
\label{ch:astris:detail:p2p}

The Astris inter-node communication is done via gRPC  \itodo{add grpc url footnote} over a tight interface, consisting of only two methods and four message definitions. It is so simple the entire spec in the Protocol Buffer \itodo{add proto buf url footnote} syntax can be included here:

\begin{verbatim}
syntax = "proto3";
package astris;
service AstrisV1 {
  rpc RecvBlocks(ElectionID) returns (stream BlockHeader) {}
  rpc GetBlock(BlockID) returns (FullBlock) {}
}
message ElectionID { bytes id = 1; }
message BlockID    { bytes id = 1; }

message BlockHeader {
  bytes prev_id = 1; //
  bytes payload_hash = 2; // this should match the payload
  fixed32 timestamp = 3; // unix timestamp of block creation
  fixed32 nonce = 4; // proof of work
  fixed64 depth = 5; // block height or chain depth
}
message FullBlock {
  BlockHeader header = 1;
  bytes payload = 2;
}
\end{verbatim}

\todo{Should peer discovery be part of the specification?}

Note that the service is \texttt{AstrisV1} to correspond with the current version of this specification. The gRPC service definition here is absolutely part of that specification as it describes how other implementations must communicate with each other. Note that the design is also such that each node will ask other nodes for information by means of connecting to the interface and awaiting data. That is, each method is a single direction stream of data, so each node will have to connect to and be connected to be each other node. This is by design, so the network can be run in a client-server, star topology as well as a peer-to-peer, mesh topology.

The second method \texttt{RecvBlocks} asks the remote peer to send it new blocks for the given \texttt{ElectionID} as it receives them. This could be a block the peer has just mined and is distributing to other peers, or it could be a block that the peer has received and re-broadcast. The remote peer should send it's current highest block in the chain immediately. This will allow the caller to ascertain whether they have the same chain and the respective depths. This will likely be called

The third method \texttt{GetBlock} asks the remote peer to send the full data for a given \texttt{BlockID}. After the node has the \texttt{BlockID} of a given head-of-chain, it can then recursively request previous blocks until the chain is complete.

The blockchain used for Astris is not a permanent one, it is ephemeral, existing only for the duration of the election and designed to allow all parties the opportunity to audit and validate the chain, detecting tampering in real-time.

The structure of the blockchain in the Astris chain is described in the \autoref{appendix:blockchain}, along with the proof of work algorithm used to perform the first layer of validation for new blocks. Subsequent block validation --- that is validation of the block payload being of the correct type and allowed at the current point in time is covered specifically in each phase description in the later sections of this chapter.

\subsection{Setup Phase}
\label{ch:astris:detail:setup}

The setup phase involves the Authority, Registrar and Trustees and is done before the blockchain is created. The data created in the phase will form the genesis block for the chain for this election.

\begin{enumerate}
    \item The Authority decides on the \nameref{dt:elgamal:params} $EG$, the number of Trustees $l$ and the required number of Trustees to decrypt the votes $t$
    \item Each Trustee is assigned an index $i$ where $0 <= i < l$,
    \item The Authority sends each Trustee their initial data $(EG, i, t)$
    \item Each Trustee Creates their \nameref{dt:setup:trustee} from the initial data and returns it to the Authority.
          \begin{enumerate}
              \item Let $p,q,g$ be the parameters from $EG$.
              \item Generate two \nameref{dt:elgamal:keypair} objects from $EG$. Label one as signing keypair and one as encryption keypair.
              \item Let the public key of the signing keypair be $P_{sig}$ and the public key of the encryption keypair be $P_{enc}$.
              \item Create a \nameref{dt:elgamal:pok} $Z_{enc}$ of the secret key corresponding to $P_{enc}$.
              \item Create $C$ an ordered list of $t$ random integers modulo $q$.
              \item For each $c \in C$, calculate the exponent $e = g^c mod p$. Let $E$ be the ordered set of all the exponents for each $c$.
              \item Create a \nameref{dt:elgamal:sig} $S$ over $(i, E, P_{sig}, P_{enc}, Z_{enc})$ by creating a message: \itodo{message}
              \item The trustee returns $(i, E, P_{sig}, P_{enc}, Z_{enc}, S)$ to the Authority and keeps hold of the secret keys and coefficients.
          \end{enumerate}
    \item The Registrar creates their \nameref{dt:setup:registrar} data from the initial data and returns it to the Authority.
          \begin{enumerate}
              \item Generate a \nameref{dt:elgamal:keypair} from $EG$ to use as a signing key.
              \item The registrar must provide a registration URL $U_r$ where the webpage must provide the facility to authenticate the voter and provide them with the information for them to complete the \nameref{ch:astris:detail:registration}.
              \item Create a \nameref{dt:elgamal:sig} $S$ over $(P_{sig}, U_r)$
              \item Return $(P_{sig}, U_r, S)$ to the Authority.
          \end{enumerate}
    \item The Authority verifies all the proofs and signatures.
    \item The Authority validates that the published exponents from each Trustee \itodo{what do we validate here, they multiply to 0?}
    \item The Authority downloads the voter list from the URL given by the registrar and verifies the hash is correct.
    \item The Authority then fills in the rest of the data required in the \nameref{dt:payload:setup} using the responses from the Trustees and the Registrar
    \item The authority then creates a genesis block using the \nameref{proc:json} of the setup data, starting the election.
\end{enumerate}

Once the genesis block is created, the Authority starts a peer-to-peer node service for the election and publishes the peer address as a \texttt{host:port} pair and the election ID.

At this point any node may connect and watch the growth of the chain by following the rules described in each section for adding new blocks to the chain.

From this point onwards the setup data are fixed provide a reference for all cryptographic and time-sensitive processes in the following steps.

\subsection{Parameter Confirmation Phase}
\label{ch:astris:detail:params}

This phase involves the Trustees, and each must produce two blocks each for the chain. All trustees must add the first of these blocks before any can add the second. All trustees must add both blocks in the allotted time period specified in the setup data timing section using \texttt{setup.timing.parameterConfirmation} and \texttt{setup.timing.timeZone} to calculate the minimum and maximum times allowed for the blocks to be added.

\todo {This list is still draft}

\begin{enumerate}
    \item For Each trustee with index $i$
          \begin{enumerate}
              \item Create the secret shares for each other Trustee $j$ as $S_{ij}$ encrypting them with the Trustee's published public encryption key.
              \item Sign the set of shares.
              \item Mine the data into a block and publish.
          \end{enumerate}
    \item Wait until all trustees have added their blocks
    \item Each trustee $i$:
          \begin{enumerate}
              \item decrypts all $S_{ij}$ and computes their key pair shard of the distributed key.
              \item creates a PoK of their Secret part
              \item creates a signature over the public key and pok.
              \item publishes the pok, public key and signature on the chain
          \end{enumerate}
\end{enumerate}

After this all participants have enough data to combine the public key shards into a combined public key to use for encrypting votes.

\subsection{Voter Registration Phase}
\label{ch:astris:detail:registration}

This phase involves the Voters and the Registrar. Timings via \texttt{setup.timing.voterRegistration}

\todo {This list is still draft}

\begin{enumerate}
    \item Each eligible voter creates a keypair for the election using the ElGamal parameters in the setup data.
    \item They then use a browser to navigate to (a GET request) the registration URL with the additional of the extra URL parameters:\\ \verb|election=<electionid>&public_key=<voter_public_key_json>|
    \item The remote URL authenticates them via whichever mechanism the registrar approves.
    \item The registrar gives the voter a unique id for this election, and creates a signature over the electionId, the publicKey and the voterId.
    \item The registrar gives the voter the signature.
    \item The voter then publishes the block with the voterId, voter public key and registrar signature.
\end{enumerate}

Note that we define the mechanism for propagating the election identifier and the voter's public key to the Registrar, but do not specify how the Registrar should return the data. This is deliberate as each implementation of the voting software may have a different mechanism for accepting the data back. We could use a redirection based approach similar to OAuth, with the opportunity for an \emph{out-of-band} method for non-URL-based interfaces. However, that would complicate the protocol beyond the scope of this report.

\subsection{Vote Casting Phase}
\label{ch:astris:detail:vote}

% Once the election is opened, voters may vote by creating a number of encrypted votes (one for each candidate), encrypted with the public key for the election. These votes will be assured to each be representing 0 or 1 by means of a zero-knowledge proof. We can them also combine an overall proof that the sum of the votes is less than a threshold (probably $1$ in most cases but sometimes $x$ where $0 < x \le num_{candidates}$). The ElGamal based system we will use for the encryption makes the proofs fairly simple and very compact.

\subsection{Tally Decryption Phase}
\label{ch:astris:detail:tally}

\subsection{Verification Phase}
\label{ch:astris:detail:verify}
