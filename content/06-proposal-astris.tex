
\chapter{Proposal for an Improved Protocol: Astris}
\label{ch:astris}

This chapter looks at a proposal for new e-voting protocol. The focus of the new protocol will be minimizing the trust requirements of the user. It will achieve this by distributing single points of trust as far as practical and ensuring real-time universal verifiability.

\begin{quote}
    ``There are only two hard things in Computer Science: cache invalidation and naming things.''

    \rightline{--- Phil Karlton\footnote{This quote was attributed to Phil Karlton by Tim Bray, first appearing on the Internet in 2005 \url(http://www.tbray.org/ongoing/When/200x/2005/12/23/UPI).}}

\end{quote}

Fortunately our protocol description does not touch on cache invalidation. However, the protocol bears a distinct resemblance to the Helios v4 protocol. This is due to the fact that many constructs within Helios are perfectly suited to application in this protocol. There are also significant differences in both the way elections are set up, voters registered and how the public bulletin board is constructed. Therefore, \emph{Astris} --- one of the daughters of Helios in Greek mythology --- seemed a fitting name.

\section{Objectives and Non-Objectives}
\label{ch:astris:aims}

Astris aims to lower the trust requirements in comparison to other voting systems while maintaining the key security properties. This is achieved through a combination of processes working together.

Firstly, the system is designed for all working to be done in the open or to be provably correct via public data. This is the primary function of using \gls{dlt} in the system --- to provide a platform that is publicly verifiable and immutable. After data is on the chain, it cannot be rewritten without nodes on the network noticing.

Secondly, the system is designed to reduce the possible single points of trust to distributed ones. No single entity will be able to decrypt the data on the chain. The registrar has a large amount of power over the system, being the one making the decisions about who is eligible or not. This is an unavoidable focus of power, but we mitigate it by ensuring that the registrar may only wield this power during the voter registration phase and not during the voting phase.

The ability to decrypt the final tally is gifted to the trustees, and only when working in concert through threshold cryptography. This means we have a bound on the number of trustees that must collude before any data is revealed. There is a trade-off here between robustness and security in the choice of our threshold. If we require that all trustees be honest, and we require them all to decrypt the final tally, this will be most secure and only one need be honest to prevent any secret data being decrypted. However, it now only takes a single dishonest party to break the system completely making the final result unknowable, as the withholding of a single decryption will reveal no information about the result. Same outcome would happen if any trustee lost their secret key before the vote decryption phase. On the other hand, if we lower the threshold too much, then fewer trustees need to be dishonest and collude before all the private votes can be decrypted.

There is no correct answer to this trade-off except to consider the circumstances of the election and the required security vs robustness. For example a national level election requires high security, but also must be robust. The electorate will not be happy if the election system fails at the end and has to be restarted, yet neither will they be happy if their votes are revealed. The way to increase both security and robustness is to increase the number of trustees, selecting them carefully to maximize the likelihood that they will not collude --- that is, where there is incentive for them to act correctly, and no shared motivation to collude with other parties. Once the number of trustees is high enough, we can choose a threshold where the probability of lost keys causing failure and the probability of the required amount of trustees colluding are both acceptably low.

Finally, it is worth reiterating that an e-voting system can never attain coercion-resistance (see \autoref{ch:ev:specific}), so we will not aim to cover that property.

We must make some assumptions about the environment in which this protocol will operate:

\begin{itemize}
    \item We are not ``programming Satan's computer'' \cite{andersonProgrammingSatanComputer1995}. That is we must assume that each entity can trust the use of their own computer system and the integrity of the software running on it.
    \item We assume the existence of a private communication channel that can be established as needed between any to entities in the system.
\end{itemize}

With this in mind, the aims of the Astris protocol are defined in \autoref{table:astris:aims}

\begin{table}[h]
    \centering
    \begin{tabular}{|Sr S{p{0.9\textwidth}}|}
        \hline
        \textbf{\#} & \textbf{Objective}                                                                                                                                                    \\
        \hline\hline
        \textbf{1}  & Create a voting protocol that is correct, secret, fair, robust, receipt-free, individually and universally verifiable, universally auditable and honours eligibility. \\
        \hline
        \textbf{2}  & Create a voting protocol with no single points of trust, minimizing trust requirements.                                                                               \\
        \hline
        \textbf{3}  & Create a voting protocol which maximizes auditability and transparency.                                                                                               \\
        \hline
    \end{tabular}
    \caption{Table of Objectives for the Astris Protocol}
    \label{table:astris:aims}
\end{table}


The non-goals of the protocol are:

\begin{itemize}
    \item To define the exact authentication protocol to prove eligibility.
    \item To define the \emph{correct} balance between security and robustness.
    \item To provide defence against a post-quantum adversary.
\end{itemize}

This last non-goal is an interesting one, that later work may wish to revisit. In order to create the protocol in the manner proposed, we will require a public key encryption system with the following properties:

\begin{itemize}
    \item There must be a distributed threshold key generation protocol without any party gaining knowledge of the secret key at any point during the protocol. This is important to ensure that there is no possibility to decrypt the data without a threshold of keyholders working together.
    \item It must be a probabilistic encryption. That is the same plaintext must not always encrypt to the same ciphertext. This is important as votes are going to have little variation in plaintext (i.e. they will be 1 or 0).
    \item It must support homomorphic addition. This is so we can add up the votes without decrypting them. There is an alternative to homomorphism in voting systems using mix-nets, but our protocol will homomorphism, and so requires an additive homomorphism.
    \item It must have a signature scheme, which can sign arbitrary messages.
    \item It must support verifiable encryption. We must be able to proof that our vote plaintext has a certain format, and the combined votes have a certain format. That is, we need to be able to prove that we voted for at most 1 candidate --- the vote for each candidate is either a 0 or a 1, and the sum over the votes for all candidates the sum of votes is also 0 or 1.
    \item It must support verifiable decryption. A trustee must be able to prove that their decryption of the tally is correct.
\end{itemize}

There are a number of quantum-resistant algorithms \needcite{LWE, Ring-LWE, NTRU, mulitvariate, supersingular ECC,... } that fit some or all of these properties. ElGamal, while relying on the \gls{dlp} which has shown to be insecure under Shor's alorigthm \cite{shorAlgorithmsQuantumComputation1994}, has all the required properties. Provided all else is equal, using a post-quantum algorithm would indeed lower trust requirements as it would be more likely that the publicly available audit data for the election could \emph{never} be decrypted by an adversary, whereas under ElGamal a post-quantum attack could reveal data. Therefore, should we be able to replace our quantum-vulnerable algorithm with a quantum-resistant one, we would further reduce trust requirements in our system, but this reduction would be orthogonal to any other aspect. It would merely be replacing one black box with another.

Given this and that the post-quantum algorithms are significantly more complex to implement in software, I leave that as future work and accept that the solution will not be optimally minimized without post-quantum algorithms but that the core of this protocol would be unchanged by switching to one. Due to this, \autoref{ch:astris:overview} will not mention any specific cryptography and the exact nature of the implementation will be detailed only in \autoref{ch:astris:detail}.

\section{Protocol Overview}
\label{ch:astris:overview}

The Astris protocol is split into distinct stages. There is a setup stage where the election parameters are chosen, the trustees named and the distributed secret key created. This stage also names the Registrar and enumerates all the eligible voters. Once this initial setup stage is complete, the data is put into a genesis block for the public audit chain for this election and the hash of the block becomes the election identifier used throughout the rest of the protocol. All further data are added to this chain, and any party wishing to verify the election as it happens can join the network and see all the blocks.

One section of the election parameters governs the timing of the phases, which will be used throughout the rest of the protocol.

The second stage is the parameter confirmation stage which is a timed stage. During this all the external parties --- the registrar and each of the trustees --- sign an acknowledgement that they agree with the data in the genesis block. Any further stages of the distributed key setup will happen here, so this may be a multi-step phase. Each signed payload is added to the chain. All confirmations must be added within the time bounds or the protocol is deemed failed and must be restarted. We note that at this stage we require \emph{all} parties to confirm, and the protocol can collapse due to a single failure. However, we have not involved the public yet, except early auditors, and so there is little problem in restarting the process, generating a new election ID.

After the parameter confirmation, we have the voter registration phase which is also a timed phase. During this phase, the voters must authenticate with the registrar and have the registrar sign their public key and voter id. The voter may then add this block to the chain, to show that their vote may be allowed and that it will be signed with their secret key. If eligible voters do not register to vote during this period, they may not cast a vote in the later vote casting stage.

The next stage is the vote casting stage, also timed. Once voting opens, a voter may cast a vote by encrypting a series of 0's or 1's in the order of the listed candidates. Alongside the encrypted votes the voter will create a series of \glsplural{zkp} showing that each ciphertext encrypts either a 0 or a 1. The voter will also create a proof that the overall sum of votes is less than or equal to the configured election parameter minimum. Finally, the voter creates a signature over the ballot data and voter id with their private key. This signature can then be verified using the previously published public key.

The last stage is the tally decryption stage, also timed. This poses the most threat to the integrity of the election as unless a threshold of trustees submits partial decryption results to the chain within the time bound, then the election will be void. It seems a legal incentive here would be necessary to ensure co-operation. Note that any entity may perform the homomorphic summation to get to the final encrypted tally, and once the threshold of partial decryption results have been published any entity may calculate the final result.

This process is visualized in \autoref{fig:astris-sequence}.

\begin{figure}[H]
    \centering
    \includesvg[width=\columnwidth]{figures/astris-protocol}
    \caption{Astris Protocol Sequence}
    \label{fig:astris-sequence}
\end{figure}

\section{Protocol Detail - V1}
\label{ch:astris:detail}

\todo{This is the fine detail - I will likely write up this bit once the software is finished in case of feedback\dots}

\subsection{Setup Phase}
\label{ch:astris:detail:setup}

% If not all trustees or not all registrars have committed to the parameters with at least one block by the freeze date, then election is void. This ensures that the regsitrars and trustees are indeed willing to participate and deepens the initial chain to the point that re-writing it will be impossible to the satisfaction of the trusted parties. Note that the public have no say in this initial setup, nor have any possibility to deepen the chain themselves, however they can watch the chain at all times and after all additions, so it is tamper-evident.

\subsection{Parameter Confirmation Phase}
\label{ch:astris:detail:params}

\subsection{Voter Registration Phase}
\label{ch:astris:detail:registration}

\subsection{Vote Casting Phase}
\label{ch:astris:detail:vote}

% Once the election is opened, voters may vote by creating a number of encrypted votes (one for each candidate), encrypted with the public key for the election. These votes will be assured to each be representing 0 or 1 by means of a zero-knowledge proof. We can them also combine an overall proof that the sum of the votes is less than a threshold (probably $1$ in most cases but sometimes $x$ where $0 < x \le num_{candidates}$). The ElGamal based system we will use for the encryption makes the proofs fairly simple and very compact.

\subsection{Tally Decryption Phase}
\label{ch:astris:detail:tally}

\subsection{Verification Phase}
\label{ch:astris:detail:verify}
