
\chapter{Implementation}
\label{ch:sw}

\section{Objectives of the Implementation}
\label{ch:sw:objectives}

The implementation of the Astris voting system will be utility-first. It is intended to prove the feasibility of creating such a system and provide an insight into the practical application of the protocol. User-friendliness will not be a priority, nor efficiency, but instead correctness will be the focus. This extends to some aspects of the peer-to-peer networking such as automatic peer-discovery and black/white listing capability (although these features may be implemented in the fullness of time).

The objective of the implementation is to create a software service that can adhere to the protocol and can perform the roles of:

\begin{itemize}
    \item \textbf{Authority:} the election organizer role. Creating the initial election parameters and setup information, the pieces required to allow the trustees and registrar to perform their setup duties and to create the genesis block.
    \item \textbf{Trustee:} one of the decryption trustees. Participating in the distributed key generation algorithm in the setup phase, and performing the partial decryption in the tally phase.
    \item \textbf{Registrar:} the eligibility authority. Creating the setup parameters, keys and voter list. Running a web-server to provide a dummy authentication module to allow voters to have there voting keys signed.
    \item \textbf{Voter:} a potential voter. Creating a voting key-pair, creating the registration URL for the voter to authenticate with the Registrar and have their key signed. Adding the signed key to the chain.
    \item \textbf{Auditor:} a member of the network simply validating all blocks on the chain, and therefore all workings of the election.
\end{itemize}

The \textbf{Auditor} is actually performed by any of the other roles, as when they connect to the blockchain they will all validate all the blocks.

The software should show that these functions can each be run independently, with no collusion and that the privacy of the voter is maintained.

\section{Architecture of the Software}
\label{ch:sw:architecture}

I have chosen Go (\surl{https://golang.org/}) as the implementation language. This choice was for a few main reasons not least of which is that I am already familiar with the language and have implemented several small projects in it. Another good reason for the choice is that the simplicity and enforced formatting make most Go projects easily accessible to new contributors. Finally, the next biggest reason was that Go code can be trivially compiled to \gls{wasm} easily, meaning the same cryptographic code could be used in the browser as natively.

The Astris specification uses gRPC (\surl{https://grpc.io}) as the inter-node communication protocol and Go is well-supported by the gRPC toolchains.

The core blockchain in the Go implementation will be backed by an SQLite database for simplicity. Only a simple key-value store is required, but SQLite will aid in ad-hoc debugging and will function happily as a key-value store. It is one of the most widely deployed pieces of software in existence \cite{MostWidelyDeployed} and so reliability should not be an issue.

The payload for the blocks will be represented as arbitrary byte arrays at the blockchain level, and the extra validation of the Astris protocol will be performed at a higher level. While this will keep the basic block validation simpler, we will still need Astris specific validation before we can accept the blocks as their format and type is dependent on the stage of the election and the previous block's data --- such as previously added signature verification keys.

The code for this project is versioned with the Git version control software and a copy of the repository is located on GitHub: \surl{\astrisrepo}.

\section{Notes on Implementation}
\label{ch:sw:notes}

As with any software project, pinning down the scope of the work and the requirements is essential. However, in a project such as this, the implementation itself fed back practicality information to the design and the final output of both have been mutually influential. Initially, it was intended to be a more complete software application, but as the implementation itself took a considerable amount of time, some of the more user-experience focused features where dropped in favour of providing the core functionality correctly.

A notable example of a feature that would be almost essential in a production-ready implementation of Astris is the automated peer-to-peer discovery methods (as mentioned earlier) and \gls{nat} traversal. Both of these problems have common solutions: DHT (e.g. Kademlia \cite{maymounkovKademliaPeertopeerInformation2002}, Chord \cite{ionstoicaChordScalablePeertopeer}) for discovery and STUN/TURN (\rfc{8656}) for \gls{nat} traversal and could be added to this implementation in the future. The lack of these feature does not prevent the software from working, but instead the software requires more complex configuration. To counter the issues the STUN/TURN aim to solve, instead a carefully designed API lowers the impact of the issue, mitigating it completely for the common use cases.

It turns out that the peer-to-peer networking code was tricky to get working correctly, as it has many failure models that must be taken into account: slow/unresponsive nodes, badly behaved nodes, intermittent node connection. In contrast, the cryptographic code --- which I had expected to be more complex --- was fairly straightforward to implement from the papers \needcite{cortierDistributedElGamalPedersen, elgamal} describing the constructs. This code will require scrutiny as although it functions correctly, such code involving cryptography is only ever resilient against the attacks it is known to defends against, and the unknown attacks that were not planned for may still lead to insecurities. Such code can be subtly insecure due to side-channel or timing-attack vulnerabilities rather than bugs in the encryption processes directly.
