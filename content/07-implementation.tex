
\chapter{Implementation}
\label{ch:sw}

\section{Objectives of the Implementation}
\label{ch:sw:objectives}

The implementation of the Astris voting system will be utility-first. It is intended to prove the feasibility of creating such a system and provide an insight into the practical application of the protocol. User-friendliness will not be a priority, nor efficiency, but instead correctness will be the focus. This extends to some aspects of the peer-to-peer networking such as automatic peer-discovery and black/white listing capability (although these features may be implemented in the fullness of time).

The objective of the implementation is to create a software service that can adhere to the protocol and can perform the roles of:

\begin{itemize}
    \item \textbf{Authority:} the election organiser role. Creating the initial election parameters and setup information, the pieces required to allow the trustees and registrar to perform their setup duties and to create the genesis block.
    \item \textbf{Trustee:} one of the decryption trustees. Participating in the distributed key generation algorithm in the setup phase, and performing the partial decryption in the tally phase.
    \item \textbf{Registrar:} the eligibility authority. Creating the setup parameters, keys and voter list. Running a web-server to provide a dummy authentication module to allow voters to have there voting keys signed.
    \item \textbf{Voter:} a potential voter. Creating a voting key-pair, creating the registration URL for the voter to authenticate with the Registrar and have their key signed. Adding the signed key to the chain.
    \item \textbf{Auditor:} a member of the network simply validating all blocks on the chain, and therefore all workings of the election.
\end{itemize}

The \textbf{Auditor} is actually performed by any of the other roles, as when they connect to the blockchain they will all validate all the blocks.

The software should show that these functions can each be run independently, with no collusion and that the privacy of the voter is maintained.

\section{Architecture of the Software}
\label{ch:sw:architecture}

I have chosen Go (\url{https://golang.org/}) as the implementation language. This choice was for a few main reasons not least of which is that I am already familiar with the language and have implemented several small projects in it. Another good reason for the choice is that the simplicity and enforced formatting make most Go projects easily accessible to new contributors. Finally, the next biggest reason was that Go code can be trivially compiled to \gls{wasm} easily, meaning the same cryptographic code could be used in the browser as natively.

I have chosen to use gRPC (\url{https://grpc.io}) as the inter-node communication protocol as hopefully it should make third party implementations more straightforward as they can share the Protocol Buffer definitions and code generation properties of gRPC.

The core blockchain in the Go implementation will be backed by a simple key-value store rather than a relational database. The portability of the data is not a problem as all transfer of data is done via the peer-to-peer methods over gRPC. Therefore, the choice of persistent datastore is an implementation detail rather than a protocol detail. A key-value store is simple enough as we will only ever wish to lookup data by the block hash, so no higher level query language is required.

The payload for the blocks will be represented as arbitrary byte arrays at the blockchain level, and the extra validation of the Astris protocol will be performed at a higher level. While this will keep the basic block validation simpler, we will still need Astris specific validation before we can accept the blocks as their format and type is dependent on the stage of the election and the previous block's data --- such as previously added signature verification keys.

The code for this project is versioned with the Git version control software and a copy of the repository is located on GitHub. The software may well see further development after this report is completed so for reference, the version at the time of publishing is available at \url{\astrisrepo /tree/ \astrishash}.

\section{Notes on Implementation}
\label{ch:sw:notes}

As with any software project, pinning down the scope of the work and the requirements is essential. However, in a project such as this, the implementation itself fed back practicality information to the design and the final output of both have been mutually influential. Initially, it was intended to be a more complete software application, but as the implementation itself took a considerable amount of time, some of the more user-experience focused features where dropped in favour of providing the core functionality correctly.

A notable example of a feature that would be almost essential in a production-ready implementation of Astris is the automated peer-to-peer discovery methods (as mentioned earlier) and \gls{nat} traversal. Both of these problems have common solutions: DHT \needcite{DHT} for discovery and STUN/TURN \needcite{stun/turn} for \gls{nat} traversal and could be added to this implementation in the future. The lack of these feature does not prevent the software from working, but instead the software requires more complex configuration.

It turns out that the peer-to-peer networking code was tricky to get working correctly, as it has many failure models that must be taken into account: slow/unresponsive nodes, badly behaved nodes, intermittent node connection. In contrast, the cryptographic code --- which I had expected to be more complex --- was fairly straightforward to implement from the papers \needcite{cortierDistributedElGamalPedersen, elgamal} describing the constructs. This code will require scrutiny as although it functions correctly, such code is can be insecure due to side-channel or timing-attack vulnerabilities rather than bugs in the encryption processes directly \needcite{crypto vulns}.


