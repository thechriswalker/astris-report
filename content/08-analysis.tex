
\chapter{Analysis}
\label{ch:analysis}

\section{Analysis of the Proposed Protocol}
\label{ch:analysis:analysis}

Does the proposed protocol achieve the objectives intended? \autoref{table:astris:aims} listed the objectives of the protocol. The first objective was concerned with the security properties of the protocol. It aimed to achieve correctness, secrecy, fairness, robustness, receipt-freeness, individual verifiability, universal verifiability, auditability and eligibility.

We will discover as we cover these properties that many rely on the existence of sufficient honest Trustees to make it impossible for a group of dishonest Trustees large enough to be capable of decryption of vote data independently. This in fact was the purpose of requiring a threshold of Trustees to participate in decryption and the exact number of Trustees and the threshold required for decryption should be chosen with care according to the threat model of the specific election. As we look at specific properties we will note if they are broken by a failure of this threshold, but not consider that a failing of the protocol. Similarly, we will assume any adversary cannot break or subvert the encryption directly.

The proposal does achieve correctness: all votes cast are cryptographically ensured to be cast according to the rules of the election. The tallying process can be performed by any party and the decryption of the tally is also similarly verifiable. As such any incorrect tally or invalid vote can be detected.

The proposal achieves secrecy to a point. There are two ways that an attacker might be able to link the encrypted vote to the voter who cast it. The Registrar holds the information for this link during the registration phase of the process, but a dishonest entity could keep the data afterwards. Another threat comes from the public nature of the internet, over which the blocks on our chain are shared. While a large scale attack would not be feasible: a targetted Sybil attack ---discussed in \autoref{ch:blockchain:trust}--- could isolate a voter from enough peers that the adversary could intercept their submitted vote and link it to them with high confidence. However, neither of these reveal the plaintext vote.

The real threat to secrecy is that there is ``toxic waste'' created in the voting process, that is the randomness required in the encryption and \gls{zkp} creation. The voter has to have this information to correctly encrypt the vote and prove its validity. If the voter keeps this information, combined with the knowledge they have of which encrypted vote is theirs, they would be able to prove they voted a specific way. This breach of secrecy is a direct result of the lack of \emph{receipt-freeness} in this protocol, discussed further shortly.

The fairness property is provided under our assumption of enough honest Trustees, as no individual votes can be decrypted without a large enough group of Trustees and the ciphertexts and proofs in the vote do not reveal any information about the candidates voted for.

The robustness property is provided to a degree. An adversary cannot introduce errors into the system as they would be detected by all honest participants. The Adversary could not alter votes in the system for the same reason. The peer-to-peer nature of the protocol has advantages and disadvantages when it comes to robustness in the face of adversarial nodes. Theoretically the adversary could mount a \gls{dos} attack against the network, flooding it with malicious nodes or preventing legitimate communication between nodes. No distributed system is free from this issue, which is well known as the Byzantine Generals Problem \cite{lamportByzantineGeneralsProblem1982}. The usual discussion of the problem dismisses the pathological case where the enemy intercepts and destroys all messages, which is possibly the simplest attack if \gls{dos} is the goal. Our protocol does not deal with this, either in the pathological case, or in a takeover attempt (a 51\% attack). If the intent is to stop the election and \gls{dos} attack is \emph{enough}, but if it is to sway the election then the ``rules'' of the system are embedded in the genesis block, and the genesis block ID gives the election its identifier. A change of the rules to favour an adversary would change the election ID, and could not go unnoticed.

The proposal does not provide receipt-freeness. As mentioned earlier, there is ``toxic waste'' created during the voting process. As the protocol is \emph{software-independent}, the protocol can be implemented by anyone, including an adversary. We explicitly dismiss the trustworthiness of the software the voter uses, but should the voter wish to publicize their vote, this waste data is all that is needed to prove how they voted. Some similar systems ---e.g. BeleniosRF \cite{cortierBeleniosSimplePrivate2019}--- have managed to achieve this property using a re-randomization step, such that a 3-rd party can re-encrypt the data with new randomness, whilst retaining the validity of the \glsplural{zkp} used to validate conformance to election rules. In the case of our proposal, achieving this would have introduced another entity ---let us call the entity a \emph{Sealer}--- that would handle all the votes and do the re-randomization. This could be provided in such a way that the Sealer would not know anything but the already encrypted vote, except via the implicit information in the communication between the voter and the Sealer, which without a secure and anonymous channel to communicate is significant. The Sealer would also be able to identify the sealed vote on the blockchain and so the introduction of this entity provides another vector to break secrecy. Overcoming this is a particularly tricky problem when all data must be kept public and the sealer must provide proof that the vote has been re-randomized. The author would very much have liked to create a novel solution to this problem whilst maintaining the other properties but was unable to do so during the course of this report --- perhaps future versions of the Astris protocol will be able to plug this hole.

The proposal is both individually and universally verifiable. All votes are public on the blockchain and any entity can verify the entire election process from start to finish. Individuals can be sure their cast vote is included in the tally by computing the tallies themselves. Universal verifiability is satisfied in the same way, the election data is all public except the tally decryption steps which instead are proved in zero-knowledge with publicly verifiable proofs.

The proposal is universally auditable --- this feature was the primary driver of the design of the system, all entities can confirm each step of the election from start to finish, including in real-time during the event itself. All data has been designed to be publicly released without compromising the other security properties. This led to the compromise that lost receipt-freeness, in a considered trade-off.

The second main objective was to create a protocol with no single point of trust, minimizing trust requirements. Let us consider all the entities involved in the protocol and how much trust we must put in each one.

The Authority in the protocol is the election organizer, the creator the original genesis block to start the election. That is the full extent of the participation of the Authority. They will likely publish and distribute the election identifier and run an Auditor node endpoint that other user can reliably connect to, but given we have the election identifier, they can no longer influence any aspect of the election or mutate the original election parameters. However, those original election parameters include all the details of the Registrar and the Trustees, and we cannot be sure that the details in the genesis block were not under the complete control of the Authority. Ideally the Registrar and the Trustees will be entities independent enough from the Authority that we can trust them to confirm the correctness of the situation. It does remain that in the end we have to trust the election organizer has correctly acquired the details of the entities it claims to have, and not just created keys to pretend to be them. In the author's opinion, the matter of trust here is actually not resting on the Authority, but on the Registrar or Trustee. They must be suitably publicly trustworthy or accountable to provide enough trust that they would contest the Authority if any dishonesty in the setup took place.

The Registrar is a single entity. This implies a single point of trust, which the protocol aimed to alleviate. We could have chosen to have multiple registrar entities, requiring a quorum of valid signatures to validate the voter's eligibility. This method would have put excessive burden on the voter to authenticate with a quorum of the Registrar's individually and perform the same registration step at each one. It was the author's opinion that the eligibility of a potential user to vote is likely decided in the end by a single entity. For example, in a governmental election, a voter would need to prove some form of citizenship --- a process likely controlled by a government agency. Any Registrar would have to go through that same agency to validate the eligibility of the voter, so distributing the Registrar role would be simply a shift of the single point of trust back to the entity that is really doing the validation. Therefore, a single Registrar is used in Astris. The registrar must provide key material and an authentication URL to the Authority for the genesis block in the setup phase. During the voter registration phase the Registrar must be trusted to:

\begin{enumerate}
    \item Allow eligible voters to register.
    \item Generate an opaque voter identifier for the voter which reveals no information about the voter's identity.
    \item Keep the link between the voter and the identifier secret, ideally destroying the information at the earliest moment --- the end of the registration phase.
\end{enumerate}

All of these items are required of any eligibility system, the Registrar must by definition be able to identify the voter. The data from the voter and the data the Registrar is required to provide must allow the Registrar to restrict the user to a single registration only. Therefore, the Registrar must be able to link the published data from a voter with the real voter identity irrespective of the protocol here, with the constraints of all data being public. So despite the fact we have three trust requirements here in a very important role, they are fully minimal.

The Trustees are indeed appropriately named, as they hold together the ability to reveal all votes. They\dots




\section{Comparison to Existing Protocols}
\label{ch:analysis:comparison}

Of the systems covered in \autoref{ch:ev:existing}, many used effectively the same techniques for providing the core security properties. Different forms of encryption and \gls{zkp} techniques are used, but the core functionality is roughly the same. Astris is as well very similar in many ways, and this is likely due to convergent evolution --- they are good solutions to the problem and obviously better solutions do not yet exist. They all suffer from the same drawbacks as well, in that they become increasing more fragile or complex as further security guarantees are met. For example, we can reduce trust requirements in the holders of a private key using secret-sharing methods and multi-party-computing to prevent a single entity being able to subvert the whole system. However, with every extra multi-party step, we add complexity to the process which gives the opportunity for new attack vectors to creep in. The more communication a voter must perform, the more side-channel data is produced which could potentially link the voter back to the vote without the encryption or mixing algorithms being compromised. Many schemes assume the existence of not only a private channel to communicate, but a private, anonymous channel for communication. Such channels may not be realistically available. Other trade anonymity with K-anonymity --- everything is a trade off.


\todo{
    Does it tick more boxes? Does it make different assumptions? Is there less trust required?

    I would say it ticks a few more boxes, but the assumptions are different.

    Note that on performing the implementation and actually writing the code to perform the encryption I found a number of unlisted but public reports similarly discussing evoting and trust and coming to similar conclusions. Should I mention these?
}

\section{Implementation Success and Analysis}
\label{ch:analysis:impl}

\todo{
    Did the implementation work? Did it achieve it's objectives? \\
    Does is have any obvious flaws? Where did I take shortcuts? \\
    What assumptions does it make? \\

    The implementation proved that such a system can be built, however the problems of remote voting and satan's computer put the trust back into the hands of the authorities we were hoping not to have to trust.
}
