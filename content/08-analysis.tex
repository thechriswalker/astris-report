
\chapter{Analysis}
\label{ch:analysis}

\section{Analysis of the Proposed Protocol}
\label{ch:analysis:analysis}

Does the proposed protocol achieve the objectives intended? \autoref{table:astris:aims} listed the objectives of the protocol. The first objective was concerned with the security properties of the protocol. It aimed to achieve correctness, secrecy, fairness, robustness, receipt-freeness, individual verifiability, universal verifiability, auditability and eligibility.

We will discover as we cover these properties that many rely on the existence of sufficient honest Trustees to make it impossible for a group of dishonest Trustees large enough to be capable of decryption of vote data independently. This in fact was the purpose of requiring a threshold of Trustees to participate in decryption and the exact number of Trustees and the threshold required for decryption should be chosen with care according to the threat model of the specific election. As we look at specific properties we will note if they are broken by a failure of this threshold, but not consider that a failing of the protocol. Similarly, we will assume any adversary cannot break or subvert the encryption directly.

The proposal does achieve correctness: all votes cast are cryptographically ensured to be cast according to the rules of the election. The tallying process can be performed by any party and the decryption of the tally is also similarly verifiable. As such any incorrect tally or invalid vote can be detected.

The proposal achieves secrecy to a point. There are two ways that an attacker might be able to link the encrypted vote to the voter who cast it. The Registrar holds the information for this link during the registration phase of the process, but a dishonest entity could keep the data afterwards. Another threat comes from the public nature of the internet, over which the blocks on our chain are shared. While a large scale attack would not be feasible: a targetted Sybil attack ---discussed in \autoref{ch:blockchain:trust}--- could isolate a voter from enough peers that the adversary could intercept their submitted vote and link it to them with high confidence. However, neither of these reveal the plaintext vote.


The real threat to secrecy is that there is ``toxic waste'' created in the voting process, that is the randomness required in the encryption and \gls{zkp} creation. The voter has to have this information to correctly encrypt the vote and prove its validity. If the voter keeps this information, combined with the knowledge they have of which encrypted vote is theirs, they would be able to prove they voted a specific way. This breach of secrecy is a direct result of the lack of \emph{receipt-freeness} in this protocol, discussed further shortly.

The fairness property is provided under our assumption of enough honest Trustees, as no individual votes can be decrypted without a large enough group of Trustees and the ciphertexts and proofs in the vote do not reveal any information about the candidates voted for.

The robustness property is provided to a degree. An adversary cannot introduce errors into the system as they would be detected by all honest participants. The Adversary could not alter votes in the system for the same reason. The peer-to-peer nature of the protocol has advantages and disadvantages when it comes to robustness in the face of adversarial nodes. Theoretically the adversary could mount a \gls{dos} attack against the network, flooding it with malicious nodes or preventing legitimate communication between nodes. No distributed system is free from this issue, which is well known as the Byzantine Generals Problem \cite{lamportByzantineGeneralsProblem1982}. The usual discussion of the problem dismisses the pathological case where the enemy intercepts and destroys all messages, which is possibly the simplest attack if \gls{dos} is the goal. Our protocol does not deal with this, either in the pathological case, or in a takeover attempt (a 51\% attack). If the intent is to stop the election and \gls{dos} attack is \emph{enough}, but if it is to sway the election then the ``rules'' of the system are embedded in the genesis block, and the genesis block ID gives the election its identifier. A change of the rules to favour an adversary would change the election ID, and could not go unnoticed.

The proposal does not provide receipt-freeness. As mentioned earlier, there is ``toxic waste'' created during the voting process. As the protocol is \emph{software-independent}, the protocol can be implemented by anyone, including an adversary. We explicitly dismiss the trustworthiness of the software the voter uses, but should the voter wish to publicize their vote, this waste data is all that is needed to prove how they voted. Some similar systems ---e.g. BeleniosRF \cite{cortierBeleniosSimplePrivate2019}--- have managed to achieve this property using a re-randomization step, such that a 3-rd party can re-encrypt the data with new randomness, whilst retaining the validity of the \glsplural{zkp} used to validate conformance to election rules. In the case of our proposal, achieving this would have introduced another entity ---let us call the entity a Sealer--- that would handle all the votes and do the re-randomization. This could be provided in such a way that the Sealer would not know anything but the already encrypted vote, except via the implicit information in the communication between the voter and the Sealer, which without a secure and anonymous channel to communicate is significant. The Sealer would also be able to identify the sealed vote on the blockchain and so the introduction of this entity provides another vector to break secrecy. Overcoming this is a particularly tricky problem when all data must be kept public and the sealer must provide proof that the vote has been re-randomized. The author would very much have liked to create a novel solution to this problem whilst maintaining the other properties but in the time available this was not possible --- perhaps future versions of the Astris protocol will be able to plug this hole.

The proposal



\todo{Does the protocol meet the security properties I wanted it to? \\
    Yes, but as for trust, it is reduced but is it minimal? \\
    Nope, we could have recipt-freeness if we add a Sealer, which would then need trusting but it could be a multi-party sealer, but that complicates the protocol by a non-negliible amount. Is it worth it?

}


\section{Comparison to Existing Protocols}
\label{ch:analysis:comparison}

Of the systems covered in \autoref{ch:ev:existing}, many used effectively the same techniques for providing the core security properties. Different forms of encryption and \gls{zkp} techniques are used, but the core functionality is roughly the same. Astris is as well very similar in many ways, and this is likely due to convergent evolution --- they are good solutions to the problem and obviously better solutions do not yet exist. They all suffer from the same drawbacks as well, in that they become increasing more fragile or complex as further security guarantees are met. For example, we can reduce trust requirements in the holders of a private key using secret-sharing methods and multi-party-computing to prevent a single entity being able to subvert the whole system. However, with every extra multi-party step, we add complexity to the process which gives the opportunity for new attack vectors to creep in. The more communication a voter must perform, the more side-channel data is produced which could potentially link the voter back to the vote without the encryption or mixing algorithms being compromised. Many schemes assume the existence of not only a private channel to communicate, but a private, anonymous channel for communication. Such channels may not be realistically available. Other trade anonymity with K-anonymity --- everything is a trade off.


\todo{
    Does it tick more boxes? Does it make different assumptions? Is there less trust required?

    I would say it ticks a few more boxes, but the assumptions are different.

    Note that on performing the implementation and actually writing the code to perform the encryption I found a number of unlisted but public reports similarly discussing evoting and trust and coming to similar conclusions. Should I mention these?
}

\section{Implementation Success and Analysis}
\label{ch:analysis:impl}

\todo{
    Did the implementation work? Did it achieve it's objectives? \\
    Does is have any obvious flaws? Where did I take shortcuts? \\
    What assumptions does it make? \\

    The implementation proved that such a system can be built, however the problems of remote voting and satan's computer put the trust back into the hands of the authorities we were hoping not to have to trust.
}
