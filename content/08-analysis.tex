
\chapter{Analysis}
\label{ch:analysis}

\section{Analysis of the Proposed Protocol}
\label{ch:analysis:analysis}

Does the proposed protocol achieve the objectives intended? \autoref{table:astris:aims} listed the objectives of the protocol. The first objective was concerned with the security properties of the protocol. It aimed to achieve correctness, secrecy, fairness, robustness, receipt-freeness, individual verifiability, universal verifiability, auditability and eligibility.

We will discover as we cover these properties that many rely on the existence of sufficient honest Trustees to make it impossible for a group of dishonest Trustees large enough to be capable of decryption of vote data independently. This in fact was the purpose of requiring a threshold of Trustees to participate in decryption and the exact number of Trustees and the threshold required for decryption should be chosen with care according to the threat model of the specific election. As we look at specific properties we will note if they are broken by a failure of this threshold, but not consider that a failing of the protocol. Similarly, we will assume any adversary cannot break or subvert the encryption directly.

The proposal does achieve correctness: all votes cast are cryptographically ensured to be cast according to the rules of the election. The tallying process can be performed by any party and the decryption of the tally is also similarly verifiable. As such any incorrect tally or invalid vote can be detected.

The proposal achieves secrecy to a point. There are two ways that an attacker might be able to link the encrypted vote to the voter who cast it. The Registrar holds the information for this link during the registration phase of the process, but a dishonest entity could keep the data afterwards. Another threat comes from the public nature of the Internet, over which the blocks on our chain are shared. While a large scale attack would not be feasible: a targeted Sybil attack ---discussed in \autoref{ch:blockchain:trust}--- could isolate a voter from enough peers that the adversary could intercept their submitted vote and link it to them with high confidence. However, neither of these reveal the plaintext vote.

An improvement to secrecy aspect of the protocol could be to use \gls{lrs} instead of including the voter identifier sign the votes, which would provide K-anonymity while retaining the ability to detect duplicate votes. This is possible as all public keys of voters are registered, but would require some consideration to how to choose the set of public keys to use for each signature. It would seem that in large elections it would not be practical to construct a signature from the keys of all voters as the signature size (and time to compute) grows with the number of signatures involved, so it would be necessary to use only a subset. This subset would need identifying without revealing any more data about the voter identifier than the set it belongs to. Given that we do not know all the voters that will register before the election we cannot assign cohorts at the Registrar, so a different  method must be chosen. Provided such a method could be found, and voters are split into groups of $G$ voters, then the chance of correctly guessing the link between voter and voter would be $1/G$, but the \emph{linkable} nature of the signatures would guarantee that we can detect repeat votes. This in turn would lower the trust requirements for the Registrar, as a leak of data allowing the link between voter and identifier would not directly compromise the link between voter and vote.

The fairness property is provided under our assumption of enough honest Trustees, as no individual votes can be decrypted without a large enough group of Trustees and the ciphertexts and proofs in the vote do not reveal any information about the candidates voted for.

The robustness property is provided to a degree. An adversary cannot introduce errors into the system as they would be detected by all honest participants. The Adversary could not alter votes in the system for the same reason. The peer-to-peer nature of the protocol has advantages and disadvantages when it comes to robustness in the face of adversarial nodes. Theoretically the adversary could mount a \gls{dos} attack against the network, flooding it with malicious nodes or preventing legitimate communication between nodes. No distributed system is free from this issue, which is well known as the Byzantine Generals Problem \cite{lamportByzantineGeneralsProblem1982}. The usual discussion of the problem dismisses the pathological case where the enemy intercepts and destroys all messages, which is possibly the simplest attack if \gls{dos} is the goal. Our protocol does not deal with this, either in the pathological case, or in a takeover attempt (a 51\% attack as described in \autoref{ch:blockchain:trust}). If the intent is to stop the election and \gls{dos} attack is \emph{enough}, but if it is to sway the election then the ``rules'' of the system are embedded in the genesis block, and the genesis block gives the election its identifier. A change of the rules to favour an adversary would change the election identifier, and could not go unnoticed.

The proposal does not provide receipt-freeness. There is ``toxic waste'' created in the voting process, that is the randomness required in the encryption and \gls{zkp} creation. The voter has to have this information to correctly encrypt the vote and prove its validity. If the voter keeps this information, combined with the knowledge they have of which encrypted vote is theirs, they would be able to prove they voted a specific way. As the protocol is \emph{software-independent}, the protocol can be implemented by anyone, including an adversary. We explicitly dismiss the trustworthiness of the software the voter uses, but should the voter wish to publicize their vote (or is being coerced), this waste data is all that is needed to prove how they voted. Some similar systems ---e.g. BeleniosRF \cite{cortierBeleniosSimplePrivate2019}--- have managed to achieve this property using a re-randomization step, such that a 3-rd party can re-encrypt the data with new randomness, whilst retaining the validity of the \glsplural{zkp} used to validate conformance to election rules. In the case of our proposal, achieving this would have introduced another entity ---let us call the entity a \emph{Sealer}--- that would handle all the votes and do the re-randomization. This could be provided in such a way that the Sealer would not know anything but the already encrypted vote, except via the implicit information in the communication between the voter and the Sealer, which without a secure and anonymous channel to communicate is significant. The Sealer would also be able to identify the sealed vote on the blockchain and so the introduction of this entity provides another vector to break secrecy. Overcoming this is a particularly tricky problem when all data must be kept public and the sealer must provide proof that the vote has been re-randomized. The author would very much have liked to create a novel solution to this problem whilst maintaining the other properties but was unable to do so during the course of this report --- perhaps future versions of the Astris protocol will be able to plug this hole.

The proposal is both individually and universally verifiable. All votes are public on the blockchain and any entity can verify the entire election process from start to finish. Individuals can be sure their cast vote is included in the tally by computing the tallies themselves. Universal verifiability is satisfied in the same way, the election data is all public except the tally decryption steps which instead are proved in zero-knowledge with publicly verifiable proofs.

The proposal is universally auditable --- this feature was the primary driver of the design of the system, all entities can confirm each step of the election from start to finish, including in real-time during the event itself. All data has been designed to be publicly released without compromising the other security properties. This led to the compromise that lost receipt-freeness, in a considered trade-off.

The second main objective was to create a protocol with no single point of trust, minimizing trust requirements. Let us consider all the entities involved in the protocol and how much trust we must put in each one.

The Authority in the protocol is the election organizer, the creator the original genesis block to start the election. That is the full extent of the participation of the Authority. They will likely publish and distribute the election identifier and run an Auditor node endpoint that other user can reliably connect to, but given we have the election identifier, they can no longer influence any aspect of the election or mutate the original election parameters. However, those original election parameters include all the details of the Registrar and the Trustees and all data in the genesis block \emph{is} under the full control of the Authority. We cannot be sure that the data were collected from the entities they claim to be. Ideally the Registrar and the Trustees will be entities independent enough from the Authority that we can trust them to confirm the correctness of the situation. It does remain that in the end we have to trust the election organizer has correctly acquired the details of the entities it claims to have, and not just created keys to pretend to be them. In the author's opinion, the matter of trust here is actually not resting on the Authority, but on the Registrar or Trustee. They must be suitably publicly trustworthy or accountable to provide enough trust that they would contest the Authority if any dishonesty in the setup took place.

The Registrar is a single entity. This implies a single point of trust, which the protocol aimed to alleviate. We could have chosen to have multiple registrar entities, requiring a quorum of valid signatures to validate the voter's eligibility. This method would have put excessive burden on the voter to authenticate with a quorum of the Registrar's individually and perform the same registration step at each one. It was the author's opinion that the eligibility of a potential user to vote is likely decided in the end by a single entity. For example, in a governmental election, a voter would need to prove some form of citizenship --- a process likely controlled by a government agency. Any Registrar would have to go through that same agency to validate the eligibility of the voter, so distributing the Registrar role would be simply a shift of the single point of trust back to the entity that is really doing the validation. Therefore, a single Registrar is used in Astris. The registrar must provide key material and an authentication URL to the Authority for the genesis block in the setup phase. During the voter registration phase the Registrar must be trusted to:

\begin{enumerate}
    \item Allow eligible voters to register.
    \item Generate an opaque voter identifier for the voter which reveals no information about the voter's identity.
    \item Keep the link between the voter and the identifier secret, ideally destroying the information at the earliest moment --- the end of the registration phase.
\end{enumerate}

All of these items are required of any eligibility system, the Registrar must by definition be able to identify the voter. The data from the voter and the data the Registrar is required to provide must allow the Registrar to restrict the user to a single registration only --- preventing double voting. Therefore, the Registrar must be able to link the published data from a voter with the real voter identity irrespective of the protocol here, with the constraints of all data being public. So despite the fact we have three trust requirements here in a very important role, they are fully minimal.

The Trustees are indeed appropriately named, as they hold together the ability to reveal all votes. Due to this fact, we deliberately distribute this trust amongst a group of entities. A threshold of Trustees must come together to decrypt any of the votes or tallies. This threshold is a configurable number, as is the total number of Trustees and will require that at least that number of Trustees must be dishonest before the encryption breaks down. The more Trustees an election has and the higher proportion of them are required for decryption the easier it will for the voter to trust that they will behave correctly. The other possibility is that a Trustee will fail to perform their portion of the decryption. This is a valid attack against the process, which would invalidate the \emph{robustness} property. Again the use of a threshold of Trustees for decryption means that we do not need all Trustees to enable successful decryption. So we need to trust that at least the threshold amount of Trustees will successfully decrypt the tallies. So, given an election with $n \geq 2$ Trustees, of which $m$ where $1 < m \leq n$ are required to decrypt, then we need to trust that:

\begin{enumerate}
    \item $x$ Trustees, where $x \leq n - m$, will be honest enough not to collude and decrypt sub-tallies or votes.
    \item $y$ Trustees, where $y \geq m$, will be honest enough to decrypt the final tally.
\end{enumerate}

The first item here is minimized by minimizing $n - m$. As we also encourage a larger $n$ to distribute trust, this means increasing $m$ towards $n$. The second item is minimized by \emph{reducing} $m$. While this may seem contradictory at first, in fact this second item is actually less relevant than the first as the definition of ``\emph{honest enough}'' is different in both cases. In the second case, breaking the rules will lead to a publicly visible violation which may well have other --perhaps legal--- implications for the entity involved. This public violation may be enough to dissuade the Trustee from misbehaving given that they \emph{will} be caught. The first item however is a violation which may never see the light of day. The colluding Trustees can act together and decrypt the data without being caught, even to anonymously publish the decrypted data ---without the proofs--- without incriminating themselves. Therefore, from a trust point of view, the first item is vastly more important. Our protocol, by allowing the choice of the number of Trustees and the threshold, has not directly minimized the trust requirements but allowed them to be minimized to the extent required by any particular election.

The Voter as an entity ought to be considered, although in this case it is the \emph{other} Voters that a given Voter must think about. Given that the eligibility of a Voter is the responsibility of the Registrar ---whose trust we have already explored--- and the Voter can only add their vote to the chain, there is little scope for a Voter to influence the election further than the legitimate casting of their own vote. The only route to this is the possibility of a \gls{dos} attack by using the facility for repeated voting. They could repeatedly cast their vote, adding blocks to the chain and preventing other voters from adding their own blocks. The protocol as stands does not address this attack, however it could be mitigated with a rule disallowing repeat votes under a defined combination of conditions such as a set timeframe or without an intermediate vote. So, we must trust the other Voters not to do this, which indeed is not minimal.

Finally, the Auditor is completely trustless. The Auditor role does not really exist as a specific role, indeed any entity whether involved in the election or not can act as Auditor. Any Voter can run the Auditor node to verify the election both in real-time during the event and afterwards provided some peers are still available to provide the chain data.


\section{Comparison to Existing Protocols}
\label{ch:analysis:comparison}

Of the systems covered in \autoref{ch:ev:existing}, the techniques used for achieving the core security properties of voting system where similar in nature. The use of either homomorphic encryption or mix-nets for secrecy, combined with \glsplural{zkp} for audit without revealing data were common to all of them. Astris is as well very similar in many ways, and this can be attributed to convergent evolution --- they are good solutions to the problem at hand and innovative new solutions have not emerged to prove themselves better. However, they all suffer from the same drawbacks as well: they become increasing more fragile and complex as further security guarantees are met. For example, we can reduce trust requirements in the holders of a private key using secret-sharing methods and multi-party-computing to prevent a single entity being able to subvert the whole system. But with every extra multi-party step, we add complexity to the process which gives the opportunity for new attack vectors to creep in. As we make the protocols more complex, the need for an anonymous private communication channel becomes more needed as more side-channel data is produced which could potentially link the voter back to the vote without the requirement for the encryption or mixing algorithms to be compromised. Some proposed voting systems, such as \cite{liuEvotingProtocolBased2017}, assume the existence of such a channel in order to ensure the security properties they claim. Astris specifically aims to not require such a channel, the properties of a private channel being sufficient.

Considering \gls{dlt} and its use in existing systems, there are three main classes of use:

\begin{itemize}
    \item Voting systems that use the cryptocurrencies and their transaction mechanism.
    \item Those that use cryptocurrencies with complex smart contracts to perform the logic of the voting process.
    \item Those that use the technology as the Bulletin Board to make the process auditable.
\end{itemize}

Of the systems this report has touched on that also use \gls{dlt} in their operation, they all fall into the first two categories. Some aspects of the voting process does end up on the blockchain in all of them, but the primary focus is not on public audit. There are commercial voting systems ---such as TiVi \cite{smartmaticTIVIWhitepaper} and FollowMyVote (\surl{https://followmyvote.com})--- that do use \gls{dlt} to provide the bulletin board functionality. This report did not consider those systems in depth as they are more difficult to inspect, having little published documentation as to their inner workings. However, Astris does use \gls{dlt} for exactly this purpose. Blockchains, while a fascinating technology, are not suitable for all situations. The author does not believe that cryptocurrency chains are a wise choice of medium for electronic voting. They are expensive and slow, but their immutability does provide a significant layer of trust to data stored on them. In the author's mind, they are a perfect fit for the bulletin board, as the data are public and verifiable by all. Hence, Astris deviates from the majority of systems using blockchains, as it only uses the blockchain as its audit trail.

\section{Implementation Success and Analysis}
\label{ch:analysis:impl}

The software implementation of Astris did implement the entire specification as described in this report. It was able to run through a complete election with simulated voters. The Audit node was able to verify the election and produce the final results when available. The peer-to-peer network allowed nodes to share and verify the chain data and new blocks into the system could be distributed, new peers into the network could ``catch up'' on the state of the chain from just the election identifier and a single seed peer. The software was able to play the role of each of the key entities in the system. As such the implementation did achieve the goal set out for it, which was to prove that such a system as specified could be implemented, with the only data-sharing via the blocks exchanged. Time pressure meant having to compromise on the web-based user-interface and only providing command line access to the functionality.

The performance of the system when verifying large chains was less than hoped, but no time was spent looking to optimize this, so there may well be room for improvement. The system running on an Intel i7-8550U processor could fully validate an election chain with one million voters in approximately 10 hours using only a single core for the bulk of the work. Much of the processing involved in the validation is well suited to parallelization, and so with some effort the author believes this number could be reduced significantly.

Therefore, despite the fact that the user interface for the software was clunky enough to not be suitable for non-technical users and the amount of manual steps involved in running an election, the author considers the software implementation to be a success.

The design of the software to run locally, means that all cryptographic processes occur on the user's own machine. Provided they can trust the source of the software, they can trust that it will not misbehave. Other remote voting systems (such as Helios) provide a client-server architecture where the user uses a web-browser to connect to the remote voting service. Although in the case of Helios the web UI runs cryptographic code in the user's browser, as a remote system that \emph{sends the client to us}, it is onerous to check that the code is correct, and that the server is running the code we expect. In contrast, with the Astris program, the executable can be verified via out-of-band checksums, or even compiled directly by the user. Although the program does use a web interface for some tasks, the web-server is run locally by the program, and by default picks a random ephemeral port to run on. This mitigates a range of attacks against a traditional remote web-based product.

That being said, there is plenty of room for improvement that came to light during the implementation phase. Too late in the process to be able to integrate directly, but future work could benefit from the experience. The main pain point was that the gRPC protocol for implementing the API was not a great choice. It appeared so during the research phase, as it provided a number of desirable features:

\begin{itemize}
    \item An API contract definition that has many client and server code generators to enable services in other languages to be built more easily.
    \item A well-established and mature RPC system.
    \item Works over HTTPS (over HTTP/2) so \gls{tls} would provide a secure channel for communications.
    \item Has support for authentication use \gls{tls} client certificates (and mutual certificate validation)
\end{itemize}

Unfortunately it became apparent as the peer-to-peer code was being written that this last point did not support the author as intended. We are working peer-to-peer and using a Certificate Authority somewhat defeats the purpose. Instead, the peer-to-peer connections would work best with self-signed certificates and with the certificate itself used as the identity of the peer. The implementations of gRPC did not support this use case and so the API became such that public Audit nodes would use ``real'' \gls{tls} certificates, and the clients looking to perform one of the \emph{short actions} ---such as adding a single block--- could do so without having to obtain or generate a certificate at all. If the system were re-designed, a networking library more suited to the needs of Astris should be considered.

